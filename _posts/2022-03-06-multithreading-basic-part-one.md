---
layout: post
title: "Многопоточность основы 1"
date:   2022-03-06
last_modified_at: 2022-03-08
categories: [programming]
---

Этот пост сделан основываясь на книге Джефри Рихтера "CLR via C#".

Изначально в Windows был один поток исполнения. От этого подхода отказались, так как в случае попадания в бесконечный цикл приходилось перезагружать компьютер и терять данные.

Следующим этапом развития этой операционной системы стало решение запускать каждый экземпляр приложения в отдельном процессе.

// Определение, выделить
Процесс - набор ресурсов, используемый отдельным экземпляром приложения.

Каждому процессу выделяется виртуальное адресное пространство. Это гарантирует что код и данные одного процесса будут недоступны для другого.

Процессы не решали проблему бесконечного цикла. Для её решения и были придуманы потоки. Поток // выделить курсивом // стал концепцией предназначеной для виртуализации процессора в Windows.

Каждый поток состоит из нескольких частей:
1. Объект ядра потока (thread kernel object) - набор свойств этой структуры описывает поток. Также структура содержит контекст потока, блок памяти с набором регистров процессора.
2. Блок обнаружения потока (Thread Environment Block, TEB) - адресное пространство к которому имеет быстрый доступ код приложений. Содержит заголовок цепочки исключений. Каждый блок try, в который входит поток вставляет свой узел в начало цепочки. После выхода из блока try, узел из цепочки удаляется. Содержит локальное хранилище данных используемое GDI и OpenGL.
3. Стек пользовательского режима (user-mode stack). Применяется для хранения передаваемых в методы локальных переменных и аргументов. Также он содержит адрес, показывающий, откуда начнет исполнение поток после того как текущий метод возвратит управление.
4. Стек режима ядра (kernel-mode stack) Используется когда код приложения передает агрументы в функцию операционной системы, находящуюся в режиме ядра. Аргументы копируются и проверяются. Используется для безопастности. Так же используется в случае когда ядро вызывает свои методы.
5. Уведомления о создании и завершении потоков. Если в Windows создается поток, то для всех загруженных в этот процесс DLL-библиотек вызывается метод DllMain с флагом DLL_THREAD_ATTACH, при завершении DLL_THREAD_DETACH. Некоторые библиотеки выполняют специальные операции инициализации или очистки для каждого созданного/завершенного в процессе потока.

Создание, поддержка и завершение ресурсов требует затрат времени и памяти. Так же мы теряем время из-за переключения контекста (context switching) - распределения нескольких логических процессоров на физическом процессоре.

В произвольный момент времени Windows передает процессору на исполнение один поток. Этот поток исполняется в течении такта (quantum). После завершения этого интервала контекст Windows переключается на другой поток. При этом происходит следующее:
1. Значение регистров процессора исполняющегося в данный момент потока сохраняются в структуре контекста, которая располагается в ядре потока.
2. Из набора имеющихся потоков выделяется тот, которому будет передано управление. Если поток принадлежит другому процессу, Windows переключает для процессора виртуальное адресное пространство.
3. Значения из выбранной структуры контекста потока загружаются в регистры процессора.

После переключения контекста процессор выполняет выбраный поток пока не истечет выделенное потоку время. В Windows это примерно 30мс.

// Внимание
Если в конце временного промежутка Windows продолжает исполнение уже исполняемого потока, переключения контекста не происходит. Это значительно повышает производительность.

// Внимание
Поток может самопроизвольно уступить управление до завершения такта, отказавшись от оставшейся части такта. Так же такой поток не планируется на исполнение до следующего вызывающего события. Таким образом потоки в состоянии ожидания не расходуют процессорное время. Например: Notepad ждет нажатия клавиши, пробуждает поток который обрабатывает это действие. После чего вызывается Win32-функция, сообщающая Windows о готовности к обработке следующего события ввода. Если события отсутсвуют, поток переходит в состояние ожидания.

CLR так же тратит дополнительное время на каждый поток, приостанавливая их, просматрия стеки, помечает объекты в куче и возобновляет их исполнение. Чем меньше потоков, тем производительнее будет уборка мусора.

И хотя в однопроцессорных компьютерах создание дополнительных потоков делалось для повышения отказоустойчивости приложений, сегодня компьютеры с несколькими процессорами или с многоядерными процессорами позволяют использовать потоки для повышения производительности.

Если думать только о производительности, оптимальное число потоков на машине должно быть равно числу установленных на ней процессоров. Если количество потоков превышает количество процессоров начинается преключение контекста.

В настоящее время существуют 3 вида многопроцессорных технологий:
1. Многопроцессорные решения. На материнской плате стаят несколько процессоров. Подход сходит на нет из-за дороговизны.
2. Гиперпотоковые микросхемы. Технология Intel. Позволяет одной микросхеме функционировать как две. Микросхема содержит два набора архитектурных состояний, таких как регистры процессора, при этом имеется всего один набор механизмов исполнения. Как только он прерывается из-за недостатка размера кэша, ошибочного прогнозирования ветви или зависимости по данным, микросхема переключается на другой поток. Происходит это на аппаратном уровне и Windows об этом не знает. Для операционной системы оба потока выполняются одновременно.
3. Многоядерные микросхемы.

В настоящее время CLR потоки соответсвуют Windows потокам.

## Потоки для асинхронных вычислительных операций

Этот раздел описывает как создать поток и заставить его исполнить асинхронную операцию. При этом приемы описываемые в этом разделе не рекомендуется применять на практике. Для этой цели лучше прибегать к пулу потоков(Thread pool).

Иногда нужно создать поток для выполнения конкретной операции. Обычно это связанно с выполнением кода приводящего поток в состояние отличное от обычного состояния потока из пула:
1. Поток требуется запустить с нестандартным приоритетом (все потоки пула выполняются с обычным приоритетом). Изменять приоритет не рекомендуется, к тому же изменение приоритета не сохраняется между операциями с пулом потоков.
2. Чтобы приложение не закрылось до завершения потоком задания, требуется чтобы поток исполнялся в фоновом режиме. Потоки из пула всегда являются фоновыми, и существует риск что они не успеют выполнить задание из-за того, что CLR решит завершить процесс.
3. Задания связанные с вычислениями исполняемые крайне долго
4. Необходимость преждевременно завершить исполняющийся поток методом Abort

Для создания потока потребуется экземпляр класса System.Threading.Thread, для получения которого нужно передать конструктору имя метода.

Прототип конструктора:

// code
```
public sealed class Thread : CriticalFinalizerObject, ... {
  public Thread(ParameterizedThreadStart start);
  // Редко используемые конструкторы пропущенны
}
```
Параметр start - метод выполняемый в этом потоке. Сигнатура метода должна совпадать с делегатом:
```
delegate void ParameterizedThreadStart(Object obj);
```
Создание объекта Thread не создает физический поток, для создания физического потока нужно вызвать метод Start передав в него объект (состояние), которое будет аргументом метода обратного вызова.

```
    public static class Program {
        public static void Main() {
            Console.WriteLine("Main thread: starting a dedicated thread " +
                "to do an asynchronous operation");
            Thread dedicatedThread = new(ComputeBoundOp);
            dedicatedThread.Start(5);

            Console.WriteLine("Main thread: Doing other work here...");
            Thread.Sleep(10000);

            dedicatedThread.Join();
            Console.WriteLine("Hit <Enter> to end this program...");
            Console.ReadLine();
        }

        private static void ComputeBoundOp(object state) {
            Console.WriteLine("In ComputeBoundOp: state={0}", state);
            Thread.Sleep(1000);
        }
    }
```
Результатом будет либо:
Main thread: starting a dedicated thread to do an asynchronous operation
Main thread: Doing other work here...
In ComputeBoundOp: state=5

Либо:
Main thread: starting a dedicated thread to do an asynchronous operation
In ComputeBoundOp: state=5
Main thread: Doing other work here...

Так как контролировать очередность выполнения мы не можем.

Метод Join заставляет вызывающий поток остановить выполнение кода до момента, пока поток, определенный в dedicatedThread, не завершится или не будет завершен.

## Причины использования потоков

Потоки используются по двум основным причинам:
1. Улучшение времени отклика. (Обычно для клиентских приложений с интерфесом) Выделение вычислений в отдельный поток позволяет интерфейсу реагировать на действия пользователя.
2. Производительность. (клиентские и серверные приложения) Многоядерные процессоры позволяют улучшать производительность за счет паралельных вычислений.
## Планирование и приоритеты потоков

Примечание

У некоторых разработчиков возникает вопрос: каким образом можно гарантированно запустить поток через определенное время после события? Например, запустить поток через 1 мс поле прохождения данных через последовательный порт. Ответ: это невозможно.

Это возможно в операционных системах реального времени (ОСРВ), но Windows к ним не относится. В таких системах (ОСРВ) необходимо доскональное знание оборудования на котором они работают. Должны быть известны задержки контроллера жесткого диска, клавиатуры и других компонентов. Windows расчитан на работу с разным аппаратным обеспечением. CLR код еще хуже подходит для работы в реальном врмени. Для этого много причин, в том числе динамическая загрузка библиотек, JIT - компиляция и уборка мусора.

Каждому потоку назначается уровень приоритета с нулевого (самый низкий) до 31 (самый высокий). При выборе потока передаваемого процессору, сначала рассматриваются потоки с наивысшим приоритетом и ставятся в очередь в цикле.

При наличии в очереди потоков с приоритетом 31 система никогда не передаст процессору поток с меньшим приоритетом. Это условие называется *зависанием*(starvation), а возникает оно в случае когда потоки с высоким приоритетом потребляют практически все время процессора и не дают исполняться потокам более низкого приоритета. Зависание намного реже возникает на машинах с многопроцессорной конфигурацией, на которых потоки с приоритетами 31 и 30 могут исполняться одновременно. Система всегда старается загрузить процессор, поэтому он простаивает только при отсутсвии готовых к исполнению потоков.

Потоки с высоким приоритетом всегда исполняются перед потоками с низким приоритетом вне зависимости от того, какие задания выполняют последние. Если в системе работает поток с приоритетом 5 и система определяет, что поток с более высоким приоритетом готов к работе исполнение немедленно приостанавливается (даже если поток находится в середине такта) и процессору передается новый поток.

В процессе загрузки система создает *поток обнуления страниц* (zero page thread), которому назначается нулевой приоритет. Это единственный поток в системе с таким приоритетом.

### Как решить какой приоритет назначать потоку?

Для решения этой проблемы Windows вводит абстрактную "прослойку" над уровнем приоритетов.

При разработке приложения следует решить, должно ли оно реагировать быстрее или медленнее, чем другие запущенные на этой же машине приложения. В соответствии с этим решением выбирается класс приоритета для процесса. В Windows поддерживаются шесть классов приоритетов: Idle (холостого хода), Below Normal (ниже обычного), Normal (обычный), Above Normal (выше обычного), High (высокий) и Realtime (реального времени). По умолчанию выбирается приоритет Normal, он же является самым распространенным.

Приоритет Idle можно использовать для приложений которые запускаются в системе где больше ничего не происходит. Например: хранители экрана.

Низкий может подходить для приложений собирающих статистику.

Above Normal и High нужно использовать только там где это реально необходимо. А Realtime лучше вообще не использовать. Его выбор может помешать выполнению таких системных заданий, как дисковый ввод-вывод или передача данных по сети. Поток с Realtime приоритетом может помешать вводу с клавиатуры или мыши создавая у пользователя впечатление что система перестала работать. Для выбора этого приоритета нужны веские основания, например необходимость с минимальной задержкой отвечать на события аппаратного уровня или выполнять какие-то кратковременные задания.

*Примечание*
Чтобы система работала без сбоев, процесс невозможно запустить с приоритетом реального времени при отсутствии прав на увеличение приоритета выполнения. Эта привилегия по умолчанию имеется только у администраторов и пользователей с расширенными правами.

Выбрав класс приоритета, не нужно думать о том как приложение соотносится с остальными приложениями, достаточно сосредоточиться на потоках своего приложения. В Windows поддерживаются 7 относительных приоритетов потоков: Idle (холостого хода), Lowest, Below Normal, Normal, Above Normal, Highest, Time-Critical. Эти приоритеты соотносятся с классами приоритетов процесса. По умолчанию для потоков используется обычный приоритет, соответсвенно, он применяется чаще всего.

Подводя итог, скажем, что процесс является членом класса приоритета и внутри него потокам назначаются связанные друг с другом приоритеты. Разработчики не имеют с ними дела напрямую. Это делает система.

![Определение уровня приоритета на основе класса приоритета процесса и относительного приоритета потока.](assets\2022-03-06-multithreading-basic-part-one\table.png)

Обратите внимание: в таблице нет комбинации, при которой поток получает 0 приоритет, так как он зарезервирован для потока обнуления страниц. Так же недоступны: 17, 18, 19, 20, 21, 27, 28, 29, 30 приоритеты так как они зарезервированны под драйверы устройств, работающие в режиме ядра. Так же стоит заметить что минимальный приоритет в Realtime 16, а потоки в остальных классах приоритета не могут получить уровень выше 15.

**Примечание**

Концепция классов приоритетов это абстрактное понятие, помогающее логически сопоставить относительную важность одного приложения над остальными.

**Внимание**

Лучше снизить приоритет одного потока чем повышать другого. Обычно понижение нужно если поток выполняет длительные вычисления, например компилирует код, проверяет орфографию, пересчитывает электронные таблицы и т.п. Потоки с высоким приоритетом обычно находятся в состоянии ожидания, не влияя на быстродействие всей системы. Например отслеживание нажатия клавиши Windows и отображение меню. После этого поток приостанавливается до нажатия клавиши пользователем.
