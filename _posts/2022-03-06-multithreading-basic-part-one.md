---
layout: post
title: "Многопоточность основы 1"
date:   2022-03-06
last_modified_at: 2022-03-08
categories: [programming]
---

Этот пост сделан основываясь на книге Джефри Рихтера "CLR via C#".

Изначально в Windows был один поток исполнения. От этого подхода отказались, так как в случае попадания в бесконечный цикл приходилось перезагружать компьютер и терять данные.

Следующим этапом развития этой операционной системы стало решение запускать каждый экземпляр приложения в отдельном процессе.

// Определение, выделить
Процесс - набор ресурсов, используемый отдельным экземпляром приложения.

Каждому процессу выделяется виртуальное адресное пространство. Это гарантирует что код и данные одного процесса будут недоступны для другого.

Процессы не решали проблему бесконечного цикла. Для её решения и были придуманы потоки. Поток // выделить курсивом // стал концепцией предназначеной для виртуализации процессора в Windows.

Каждый поток состоит из нескольких частей:
1. Объект ядра потока (thread kernel object) - набор свойств этой структуры описывает поток. Также структура содержит контекст потока, блок памяти с набором регистров процессора.
2. Блок обнаружения потока (Thread Environment Block, TEB) - адресное пространство к которому имеет быстрый доступ код приложений. Содержит заголовок цепочки исключений. Каждый блок try, в который входит поток вставляет свой узел в начало цепочки. После выхода из блока try, узел из цепочки удаляется. Содержит локальное хранилище данных используемое GDI и OpenGL.
3. Стек пользовательского режима (user-mode stack). Применяется для хранения передаваемых в методы локальных переменных и аргументов. Также он содержит адрес, показывающий, откуда начнет исполнение поток после того как текущий метод возвратит управление.
4. Стек режима ядра (kernel-mode stack) Используется когда код приложения передает агрументы в функцию операционной системы, находящуюся в режиме ядра. Аргументы копируются и проверяются. Используется для безопастности. Так же используется в случае когда ядро вызывает свои методы.
5. Уведомления о создании и завершении потоков. Если в Windows создается поток, то для всех загруженных в этот процесс DLL-библиотек вызывается метод DllMain с флагом DLL_THREAD_ATTACH, при завершении DLL_THREAD_DETACH. Некоторые библиотеки выполняют специальные операции инициализации или очистки для каждого созданного/завершенного в процессе потока.

Создание, поддержка и завершение ресурсов требует затрат времени и памяти. Так же мы теряем время из-за переключения контекста (context switching) - распределения нескольких логических процессоров на физическом процессоре.

В произвольный момент времени Windows передает процессору на исполнение один поток. Этот поток исполняется в течении такта (quantum). После завершения этого интервала контекст Windows переключается на другой поток. При этом происходит следующее:
1. Значение регистров процессора исполняющегося в данный момент потока сохраняются в структуре контекста, которая располагается в ядре потока.
2. Из набора имеющихся потоков выделяется тот, которому будет передано управление. Если поток принадлежит другому процессу, Windows переключает для процессора виртуальное адресное пространство.
3. Значения из выбранной структуры контекста потока загружаются в регистры процессора.

После переключения контекста процессор выполняет выбраный поток пока не истечет выделенное потоку время. В Windows это примерно 30мс.

// Внимание
Если в конце временного промежутка Windows продолжает исполнение уже исполняемого потока, переключения контекста не происходит. Это значительно повышает производительность.

// Внимание
Поток может самопроизвольно уступить управление до завершения такта, отказавшись от оставшейся части такта. Так же такой поток не планируется на исполнение до следующего вызывающего события. Таким образом потоки в состоянии ожидания не расходуют процессорное время. Например: Notepad ждет нажатия клавиши, пробуждает поток который обрабатывает это действие. После чего вызывается Win32-функция, сообщающая Windows о готовности к обработке следующего события ввода. Если события отсутсвуют, поток переходит в состояние ожидания.

CLR так же тратит дополнительное время на каждый поток, приостанавливая их, просматрия стеки, помечает объекты в куче и возобновляет их исполнение. Чем меньше потоков, тем производительнее будет уборка мусора.

И хотя в однопроцессорных компьютерах создание дополнительных потоков делалось для повышения отказоустойчивости приложений, сегодня компьютеры с несколькими процессорами или с многоядерными процессорами позволяют использовать потоки для повышения производительности.

Если думать только о производительности, оптимальное число потоков на машине должно быть равно числу установленных на ней процессоров. Если количество потоков превышает количество процессоров начинается преключение контекста.

В настоящее время существуют 3 вида многопроцессорных технологий:
1. Многопроцессорные решения. На материнской плате стаят несколько процессоров. Подход сходит на нет из-за дороговизны.
2. Гиперпотоковые микросхемы. Технология Intel. Позволяет одной микросхеме функционировать как две. Микросхема содержит два набора архитектурных состояний, таких как регистры процессора, при этом имеется всего один набор механизмов исполнения. Как только он прерывается из-за недостатка размера кэша, ошибочного прогнозирования ветви или зависимости по данным, микросхема переключается на другой поток. Происходит это на аппаратном уровне и Windows об этом не знает. Для операционной системы оба потока выполняются одновременно.
3. Многоядерные микросхемы.

В настоящее время CLR потоки соответсвуют Windows потокам.

## Потоки для асинхронных вычислительных операций

Этот раздел описывает как создать поток и заставить его исполнить асинхронную операцию. При этом приемы описываемые в этом разделе не рекомендуется применять на практике. Для этой цели лучше прибегать к пулу потоков(Thread pool).

Иногда нужно создать поток для выполнения конкретной операции. Обычно это связанно с выполнением кода приводящего поток в состояние отличное от обычного состояния потока из пула:
1. Поток требуется запустить с нестандартным приоритетом (все потоки пула выполняются с обычным приоритетом). Изменять приоритет не рекомендуется, к тому же изменение приоритета не сохраняется между операциями с пулом потоков.
2. Чтобы приложение не закрылось до завершения потоком задания, требуется чтобы поток исполнялся в фоновом режиме. Потоки из пула всегда являются фоновыми, и существует риск что они не успеют выполнить задание из-за того, что CLR решит завершить процесс.
3. Задания связанные с вычислениями исполняемые крайне долго
4. Необходимость преждевременно завершить исполняющийся поток методом Abort

Для создания потока потребуется экземпляр класса System.Threading.Thread, для получения которого нужно передать конструктору имя метода.

Прототип конструктора:

// code
```
public sealed class Thread : CriticalFinalizerObject, ... {
  public Thread(ParameterizedThreadStart start);
  // Редко используемые конструкторы пропущенны
}
```
Параметр start - метод выполняемый в этом потоке. Сигнатура метода должна совпадать с делегатом:
```
delegate void ParameterizedThreadStart(Object obj);
```
Создание объекта Thread не создает физический поток, для создания физического потока нужно вызвать метод Start передав в него объект (состояние), которое будет аргументом метода обратного вызова.

```
    public static class Program {
        public static void Main() {
            Console.WriteLine("Main thread: starting a dedicated thread " +
                "to do an asynchronous operation");
            Thread dedicatedThread = new(ComputeBoundOp);
            dedicatedThread.Start(5);

            Console.WriteLine("Main thread: Doing other work here...");
            Thread.Sleep(10000);

            dedicatedThread.Join();
            Console.WriteLine("Hit <Enter> to end this program...");
            Console.ReadLine();
        }

        private static void ComputeBoundOp(object state) {
            Console.WriteLine("In ComputeBoundOp: state={0}", state);
            Thread.Sleep(1000);
        }
    }
```
Результатом будет либо:
Main thread: starting a dedicated thread to do an asynchronous operation
Main thread: Doing other work here...
In ComputeBoundOp: state=5

Либо:
Main thread: starting a dedicated thread to do an asynchronous operation
In ComputeBoundOp: state=5
Main thread: Doing other work here...

Так как контролировать очередность выполнения мы не можем.

Метод Join заставляет вызывающий поток остановить выполнение кода до момента, пока поток, определенный в dedicatedThread, не завершится или не будет завершен.
